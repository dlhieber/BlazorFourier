@using Blazor.Extensions.Canvas.Canvas2D;
@using Blazor.Extensions.Canvas;
@using Blazor.FileReader;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.PixelFormats;
@using SixLabors.ImageSharp.Advanced;
@using SixLabors.ImageSharp.Processing;
@using Meta.Numerics.Matrices;
@using Meta.Numerics.SignalProcessing;

@inject IFileReaderService fileReader;

<img src="@imageDataAsBase64" />
<img src="@fourierimageDataAsBase64"/>
<input type="file" @ref="ogImg" @onchange="OpenFileAsync" accept=".png,.jpg,.jpeg,.gif"  />
<input type="button" @onclick="FFTCallback" title="FFT" value="Perform FFT" />

<p class="alert-secondary" @ref="loadingText">@debug</p>


@code{

    string imageDataAsBase64 = String.Empty;
    string fourierimageDataAsBase64 = String.Empty;
    protected ElementReference ogImg, loadingText;
    protected IFileInfo fileInfo;
    protected IFileReference originalFileReference;
    string debug = "";
    Image<Rgba32> convertedImage;

    /**
     * Improvement to be made:
     * Used this struc to select channels. I understand there's probably a better waying using typedef 
     * and checking which property to select
     */
    protected struct RGBAMatrix
    {
        public RectangularMatrix R;
        public RectangularMatrix G;
        public RectangularMatrix B;
        public RectangularMatrix A;
    }
    protected enum Channel
    {
        R,G,B,A
    }

    async Task OpenFileAsync()
    {
        originalFileReference = (await fileReader.CreateReference(ogImg).EnumerateFilesAsync()).FirstOrDefault();
        if (originalFileReference == null)
            return;

        fileInfo = await originalFileReference.ReadFileInfoAsync();
        var imageMemoryStream = await originalFileReference.CreateMemoryStreamAsync();


        var image = Image<Rgba32>.Load(imageMemoryStream);
        System.IO.MemoryStream resizedStream = new System.IO.MemoryStream();


        /* Improvement to be made:
         * Rectangular images should work, but until I fix the bug in the fourier code, I'm just forcing a square image
         *  for now
         */
        if (image.Height != image.Width)
        {

            if(image.Height > image.Width)
            {
                image.Mutate(x => x.Resize(image.Width, image.Width));
            }
            else
            {
                image.Mutate(x => x.Resize(image.Height, image.Height));
            }

        }

        image.SaveAsPng(resizedStream);
        debug = fileInfo.Type;
        /*
         * Improvement to be made:
         * There's probably a better way to load images in dynamically, but for now I found this example, and while slow,
         * it does work (png is also faster than jpg as far as I have noticed)
         */
        imageDataAsBase64 = $"data:png;base64,{Convert.ToBase64String(resizedStream.ToArray())}";

        convertedImage= image.CloneAs<Rgba32>();


        imageMemoryStream.Close();
        resizedStream.Close();
    }

    protected void FFTCallback()
    {
        if (!String.IsNullOrEmpty(imageDataAsBase64))
        {

            RGBAMatrix matrices = new RGBAMatrix();
            RGBAMatrix Fmatrices = new RGBAMatrix();
            matrices.R = getChannelMatrix(convertedImage, Channel.R);
            matrices.G = getChannelMatrix(convertedImage, Channel.G);
            matrices.B = getChannelMatrix(convertedImage, Channel.B);
            matrices.A = getChannelMatrix(convertedImage, Channel.A);

            Fmatrices.R= Peform2DFFT(matrices.R);
            Fmatrices.G = Peform2DFFT(matrices.G);
            Fmatrices.B = Peform2DFFT(matrices.B);

            drawFourierImage(Fmatrices);
        }
    }

    protected void drawFourierImage(RGBAMatrix matrix)
    {
        Image<Rgba32> FImage = new Image<Rgba32>(convertedImage.Width, convertedImage.Height);

        var Rmax =  matrix.R.MaxNorm();
        var Gmax =  matrix.G.MaxNorm();
        var Bmax =  matrix.B.MaxNorm();

        for (int row = 0; row < matrix.R.RowCount; row++)
        {
            for (int col = 0; col < matrix.R.ColumnCount; col++)
            {
                FImage[(col+ convertedImage.Width/2) % convertedImage.Width, (row+convertedImage.Height/2)% convertedImage.Height] =
                    new Rgba32( (float) (matrix.R[row,col]/Rmax)*255f,
                                               (float)(matrix.G[row, col] / Gmax) * 255f,
                                               (float)(matrix.B[row, col] / Bmax) * 255f, 255f);

            }
        }
        System.IO.MemoryStream FourierStream = new System.IO.MemoryStream();
        FImage.SaveAsPng(FourierStream);
        fourierimageDataAsBase64= $"data:png;base64,{Convert.ToBase64String(FourierStream.ToArray())}";
    }
    protected RectangularMatrix Peform2DFFT(RectangularMatrix input)
    {
        FourierTransformer rowFT = new FourierTransformer(input.ColumnCount,FourierSign.Negative,FourierNormalization.Unitary);
        FourierTransformer colFT = new FourierTransformer(input.RowCount, FourierSign.Negative, FourierNormalization.Unitary);
        RectangularMatrix output = new RectangularMatrix(input.RowCount, input.ColumnCount);

        List<List<Meta.Numerics.Complex>> initComplexMatrix =new List<List<Meta.Numerics.Complex>>(input.RowCount);
        List<List<Meta.Numerics.Complex>> intermediateComplexMatrix = new List<List<Meta.Numerics.Complex>>(input.ColumnCount);
        List<Meta.Numerics.Complex> complexRow;

        //convert to proper format for transformation
        for (int row = 0; row < input.RowCount; row++)
        {
            complexRow = new List<Meta.Numerics.Complex>(input.ColumnCount);
            foreach (double num in input.Row(row).ToArray())
            {
                complexRow.Add(new Meta.Numerics.Complex(num, 0));
            }
            initComplexMatrix.Add(complexRow);
        }




        //Prep intermediate matrix
        for (int col=0; col<input.ColumnCount;col++)
        {
            var emptyRow = new List<Meta.Numerics.Complex>(input.RowCount);
            intermediateComplexMatrix.Add(emptyRow);
        }

        //Perform Row FFT and Move into intermediate list for Column Transform
        for (int row = 0; row < input.RowCount; row++)
        {
            var transformedRow = rowFT.Transform(initComplexMatrix[row]);


            for (int col = 0; col < input.ColumnCount; col++)
            {
                intermediateComplexMatrix[col].Add(transformedRow[col]);
            }
        }


        //Perform Col FFT and move the real part into output matrix
        for (int col = 0; col < input.ColumnCount; col++)
        {
            var transformedCol = colFT.Transform(intermediateComplexMatrix[col]);


            for (int row = 0; row < input.ColumnCount; row++)
            {
                output[row, col] = Math.Abs(transformedCol[row].Re);
               
            }
        }

        return output;
    }
    protected RectangularMatrix getChannelMatrix(Image<Rgba32> image, Channel channel)
    {
         
        Span<Rgba32> spanRGBA;
        double [,] matrix =new double[image.Height, image.Width];

        for (int row = 0; row < image.Height; row++)
        {
            spanRGBA = image.GetPixelRowSpan<Rgba32>(row);
            for (int col = 0; col < spanRGBA.Length; col++)
            {
                switch (channel)
                {
                    case Channel.R:
                        matrix[col,row]=(double)spanRGBA[col].R;
                        break;
                    case Channel.G:
                        matrix[col,row]=(double)spanRGBA[col].G;
                        break;
                    case Channel.B:
                        matrix[col,row]=(double)spanRGBA[col].B;
                        break;
                    case Channel.A:
                        matrix[col,row]=(double)spanRGBA[col].A;
                        break;
                    default:
                        throw new ArgumentException("Invalid Channel Type");
                }

            }
     

        }

        RectangularMatrix rectMatrix = new RectangularMatrix(matrix);

        return rectMatrix;
    }



}
