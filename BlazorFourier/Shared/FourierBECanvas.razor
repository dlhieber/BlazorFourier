@using Blazor.Extensions.Canvas.Canvas2D;
@using Blazor.Extensions.Canvas;
@using Blazor.FileReader;
@using SixLabors.ImageSharp;
@using SixLabors.ImageSharp.PixelFormats;
@using SixLabors.ImageSharp.Advanced;
@using SixLabors.ImageSharp.Processing;
@using Meta.Numerics.Matrices;
@inject IFileReaderService fileReader;

<img src="@imageDataAsBase64" />
<img src="@fourierimageDataAsBase64"/>
<input type="file" @ref="ogImg" @onchange="OpenFileAsync" accept=".png,.jpg,.jpeg,.gif"  />
<input type="button" @onclick="FFTCallback" title="FFT" value="Perform FFT" />

<p class="alert-secondary">@debug</p>
@code{

    string imageDataAsBase64 = String.Empty;
    string fourierimageDataAsBase64 = String.Empty;
    protected ElementReference ogImg;
    protected IFileInfo fileInfo;
    protected IFileReference ogFileRef;
    string debug = "";
    Image<Rgba32> convertedImage;

    protected struct RGBAMatrix
    {
        public RectangularMatrix R;
        public RectangularMatrix G;
        public RectangularMatrix B;
        public RectangularMatrix A;
    }
    protected enum Channel
    {
        R,G,B,A
    }
    async Task OpenFileAsync()
    {
        ogFileRef = (await fileReader.CreateReference(ogImg).EnumerateFilesAsync()).FirstOrDefault();

        if (ogFileRef == null)
            return;

        fileInfo = await ogFileRef.ReadFileInfoAsync();
        var imageMemoryStream = await ogFileRef.CreateMemoryStreamAsync();


        var image = Image<Rgba32>.Load(imageMemoryStream);

        debug = fileInfo.Type;

        imageDataAsBase64 = $"data:{fileInfo.Type};base64,{Convert.ToBase64String(imageMemoryStream.ToArray())}";

        convertedImage= image.CloneAs<Rgba32>();



    }

    protected void FFTCallback()
    {
        if (!String.IsNullOrEmpty(imageDataAsBase64))
        {
            PeformFFT(convertedImage);
        }
    }

    protected void PeformFFT(Image<Rgba32> image)
    {
        RGBAMatrix matrices = new RGBAMatrix();
        matrices.R = getChannelMatrix(image, Channel.R);
        matrices.G = getChannelMatrix(image, Channel.G);
        matrices.B = getChannelMatrix(image, Channel.B);
        matrices.A = getChannelMatrix(image, Channel.A);
    }
    protected RectangularMatrix getChannelMatrix(Image<Rgba32> image, Channel channel)
    {

        Span<Rgba32> spanRGBA;
        List<double> channelPixels;
        List<List<double>> rowsofchannelPixels= new List<List<double>>();

        Meta.Numerics.SignalProcessing.FourierTransformer ft;

        debug += "\n";
        for (int row = 0; row < image.Height; row++)
        {
            channelPixels = new List<double>();


            spanRGBA = image.GetPixelRowSpan<Rgba32>(row);
            for (int i = 0; i < spanRGBA.Length; i++)
            {
                switch (channel)
                {
                    case Channel.R:
                        channelPixels.Add((double)spanRGBA[i].R);
                        break;
                    case Channel.G:
                        channelPixels.Add((double)spanRGBA[i].G);
                        break;
                    case Channel.B:
                        channelPixels.Add((double)spanRGBA[i].B);
                        break;
                    case Channel.A:
                        channelPixels.Add((double)spanRGBA[i].A);
                        break;
                    default:
                        throw new ArgumentException("Invalid Channel Type");
                }
                
                debug += channelPixels[i] + " ";
            }
            debug += "\n";
            rowsofchannelPixels.Add(channelPixels);

        }


        return null;
    }



}
